<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试</title>
      <link href="/2023/01/13/%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/01/13/%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="面经分类"><a href="#面经分类" class="headerlink" title="面经分类"></a>面经分类</h1><p>从我的面试记录来看，可以把面试题分成这些类型：</p><ul><li>JavaScript</li><li>CSS</li><li>框架通识</li><li>Vue</li><li>React</li><li>Webpack</li><li>Typescript</li><li>浏览器 &amp; 网络</li><li>小程序</li><li>看代码说结果</li><li>手撕代码 &amp; 算法</li><li>开放题</li></ul><p>以下是我面试过程中遇到的所有的问题，供大家参考。下面的这些题目能搞定百分之七八十，搞定面试绝对没问题。</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><ul><li>Map 和 Set 的区别，Map 和 Object 的区别</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">同</span><br><span class="line">是什么 为什么 怎么用</span><br><span class="line">map 和 set 都是ES6提供的一种新的数据类型</span><br><span class="line">他们都属于对象类型</span><br><span class="line"></span><br><span class="line">提高性能</span><br><span class="line"></span><br><span class="line">map  只需要键值对的结构时，即 key =&gt; value 的结构</span><br><span class="line">      需要字符串以外的键或者值</span><br><span class="line">set 数组去重</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在JS中的默认对象的表示方式为&#123;&#125;，即一组键值对，但是键必须是字符串。</span><br><span class="line">Map 对象是键值对集合，和 JSON 对象类似，但是 key 不仅可以是字符串还可以是其他各种类型的值包括对象都可以成为Map的键</span><br><span class="line"></span><br><span class="line">Set 对象类似于数组，且成员的值都是唯一的</span><br><span class="line">常常用来做数组去重</span><br><span class="line"></span><br><span class="line">异</span><br><span class="line">Object的键只能是字符串或者Symbols，Map的键可以是任何类型。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>数组的 filter、every、flat 的作用是什么<br>函数三要素<br>函数名 形参 函数体<br>方法<br>返回值<br>filter<br>数组的过滤方法<br>它创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</li></ul><p>every<br>用于判断数组的每一个元素是否满足条件<br>如果全部都满足 返回值为 true 如果有一个不满足 剩下的则不会执行 返回值 false</p><p>flat<br>用于扁平化数组<br>主要用于将多维数组转化为一维数组<br>// 不传参数时，默认“拉平”一层<br>arr.flat()</p><ul><li>前端开发者不得不知的 ES6 十大特性</li></ul><ul><li>const let</li><li>箭头函数 ()=&gt;{}</li><li>对象数组…扩展运算符</li><li>class 继承语法糖</li><li><code>$&#123;count&#125;</code> 模板字符串</li><li>结构赋值</li><li>Promise</li><li>形参默认值</li><li>.？可选链</li><li>ES6 新增了模块化（import / export）</li><li>Proxy 代理对象 函数</li></ul><p>+说一下对 Promise 的了解</p><blockquote><p>Promise 可以将异步操作以同步的流程表达出来, 避免了层层嵌套的回调函数(俗称’回调地狱’)<br>Promise 也是一个构造函数 它身上 all、allSettled、any、race、reject、resolve<br>all 并发请求<br>Promise 状态 padding resolve reject<br>只能从 padding 到 resolve 或者 reject<br>.then .catch .flnaly</p></blockquote><ul><li><p>Promise 实现原理</p></li><li><p>Promise 的 all 和 race 有什么区别</p></li><li><p>箭头函数和普通函数的区别</p><blockquote><p>变量不能重名<br>变量 不会 提升<br>没有this</p></blockquote></li><li><p>箭头函数和普通函数的区别</p></li><li><p>let、var 和 const 的区别？如果希望 const 定义的对象的属性也不能被修改该怎么做？</p></li><li><p>堆和栈的区别</p></li><li><p>闭包的原理</p></li><li><p>我将【闭包】讲给你听！</p></li><li><p>instanceof 的实现原理</p></li><li><p>new 的实现原理</p></li><li><p>数据类型有哪些？如何判断一个数据是否是数组</p></li><li><p>JQuery 实现链式调用的原理是什么</p></li><li><p>分别介绍一下原型、原型链、作用域和作用域链的含义和使用场景</p></li></ul><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul><li><p>css 和 js 两种方式实现 div 右移 1000px 动画</p></li><li><p>visibility、display、opacity 的区别</p></li><li><p>单行截断 css</p></li><li><p>flex 布局</p></li><li><p>flex：1</p></li><li><p>transition、transform、translate 的区别</p></li><li><p>如何画一条 0.5px 的边框</p></li><li><p>怎么画一条 0.5px 的边（更新）</p></li><li><p>说一下 BFC</p></li><li><p>浅析 BFC 原理及作用</p></li><li><p>parent 元素宽高不定，实现 scale 固定宽高比始终为 4：3</p></li><li><p>CSS 垂直居中的方案</p></li><li><p>CSS 垂直居中的 12 种实现方式</p></li><li><p>伪元素和伪类的区别</p></li><li><p>总结伪类与伪元素 | AlloyTeam</p></li><li><p>position 的几个属性和含义</p></li><li><p>CSS position 属性</p></li><li><p>说一下盒模型</p></li><li><p>响应式布局方案</p></li><li><p>前端响应式布局原理与方案（详细版）</p></li><li><p>三栏式布局方案</p></li><li><p>如何提高动画的渲染性能</p></li><li><p>这样使用 GPU 动画</p></li></ul><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><ul><li><p>computed 和 watch 的区别</p></li><li><p>data 为什么是个函数，而不是对象</p></li><li><p>watch 能监听 computed 的属性吗</p></li><li><p>vue 的响应式原理</p></li><li><p>vue 的生命周期</p></li><li><p>mounted 拿到数据可以后可以直接获取 dom 吗</p></li><li><p>nextTick 原理</p></li><li><p>vue 模板（template）里为什么不能使用多个头结点？</p></li><li><p>vuex 为什么同时设计 mutation 和 action？只设计一个行不行？</p></li><li><p>vue2 和 vue3 在数据绑定这一块有什么区别？</p></li><li><p>vue 挂载和卸载父子组件生命周期钩子执行顺序</p></li><li><p>vue 的优化方案（等同于如何编写可读性高、易维护且高性能的 vue 代码）</p></li><li><p>Vue 项目性能优化 — 实践指南（网上最全 / 详细）</p></li><li><p>keep-alive 的原理，使用有什么问题？如何解决</p></li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>在我开始投简历之前，我做了两周的面试准备，那么我准备什么呢？</p><p>首先是准备简历和自我介绍。将自己所做过的所有项目都列出来，从里面找到自己收获比较大的或者是存在着技术难点的项目放到简历上。有一点非常重要：千万不要为了显得自己很厉害，把自己不了解或者不熟悉的技术写到简历里！这是非常不明智的，面试官往往会根据你简历的所写到的技术点和项目进行提问，如果问到了你不会的技术点，你又不能很好的表达出来，那可能就吃了一个暗亏。在梳理项目的同时，最好对你的项目做一个抽象的归纳总结，比如项目的使用者有哪些人，这个项目对他们产生了什么样的帮助，这个项目所承担的职责是什么样的。</p><p>第二步是遍历。需要大批量的去看网上的面经，面经的时间越近越是有可借鉴的地方。多关注简历里面写到和项目里用到的技术，多关注原生 JS、技术框架、构建打包以及性能优化方向的知识，而对于 css 和 html 这些面试官能问到的范围比较小，所有可能被问到的 css 题目其实我都遇到过了，也都记录在了文章里。</p><p>第三步是列提纲。我根据网上的面经，我将面试官可能会问到的问题汇集起来统一记录在文档里，然后按照题目的标签和关注点进行分类，最后得到的分类结果和最后实际的面试经过所碰到的问题分类差不多。</p><p>第四步是各个击破。对于梳理出来的知识点，我建议将每一条的答案都用笔写出来或者用电脑编辑记录下来。很多时候，知道和能不能很好地表达出来没有必然的关系。不仅要知道是什么，最好也要能保证在面试官提问的时候能用清晰的语言将你所知道的表达出来。</p><p>除了以上四点，还需要注意的是算法。算法这件事情很难在短时间内训练得很熟练，更多的是需要日常的的锻炼，培养了灵活的思维意识，才能在最短的时间内从题目中分析出需要使用的算法思想。当然，如果只是为了应付面试的话，那就没有这么复杂了，前端面试中可能涉及到的算法题不是很多，你只需要会做这些常见的题目就行了，甚至不需要举一反三。</p><p>除了做准备之外，还有一件事情必须要做：复盘和总结。对于我们面试的时候所遇到的问题，一定要及时的回忆和记录下来，尤其是自己没有回答上来的问题，及时的查漏补缺，找到一个能让面试官满意的答案并记录下来，这样的记忆往往会更加深刻。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>markdowm</title>
      <link href="/2023/01/12/markdowm/"/>
      <url>/2023/01/12/markdowm/</url>
      
        <content type="html"><![CDATA[<p>标题</p><h1 id="我展示的是一级标题"><a href="#我展示的是一级标题" class="headerlink" title="我展示的是一级标题"></a>我展示的是一级标题</h1><h2 id="我展示的是二级标题"><a href="#我展示的是二级标题" class="headerlink" title="我展示的是二级标题"></a>我展示的是二级标题</h2><p>标题</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>字体</p><p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong><br><strong><em>粗斜体文本</em></strong></p><p>分隔线</p><hr><hr><hr><hr><hr><p>列表</p><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><p>列表嵌套</p><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><p>区块</p><blockquote><p>区块引用<br>菜鸟教程<br>学的不仅是技术更是梦想</p></blockquote><p>区块嵌套</p><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><p>区块列表</p><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><p>列表中使用区块</p><ul><li>第一项<blockquote><p>菜鸟教程<br>学的不仅是技术更是梦想</p></blockquote></li><li>第二项</li></ul><p>代码块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;RUNOOB&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>链接</p><p>这是一个链接 <a href="https://www.runoob.com/">菜鸟教程</a></p><p>链接变量<br>这个链接用 1 作为网址变量 <a href="http://www.google.com/">Google</a><br>这个链接用 runoob 作为网址变量 <a href="http://www.runoob.com/">Runoob</a><br>然后在文档的结尾为变量赋值（网址）</p><p>图片</p><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标"></p><p>表格</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p>表格对齐方式  </p><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>core.js 作用</title>
      <link href="/2023/01/12/core-js-%E4%BD%9C%E7%94%A8/"/>
      <url>/2023/01/12/core-js-%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="core-js-是什么？"><a href="#core-js-是什么？" class="headerlink" title="core.js 是什么？"></a>core.js 是什么？</h3><p>ECMAScript 的迅速成长以及浏览器的频繁更新换代，每年会出现新的 qpi，像：es6 的 Promise，Set 或者 es7 数组新提供的方法 includes，这些新加入的 api，就引出一个词“”polyfill“”(垫片/补丁)，就是社区上提供的一段代码，让我们在不兼容某些新特性的浏览器上，使用该新特性。新功能转换为大部分现代浏览器都可以支持运行的 api 补丁包集合。</p><h3 id="官方描述"><a href="#官方描述" class="headerlink" title="官方描述"></a>官方描述</h3><ul><li>它支持最新的 ECMAScript 标准</li><li>它支持 ECMAScript 标准库提案；</li><li>它支持一些 WHATWG/W3C 标准（跨平台或者 ECMAScript 相关）</li><li>它最大限度的模块化：你能仅仅加载你想要使用的功能；</li><li>它能够不污染全局命名空间</li><li>它和 babel 紧密结合：这能够优化 core.js 引入；</li><li>它是最普遍、最流行的给 javascript 标准库打补丁的方式；</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>主要是因为 IE 浏览器无法兼容新的语法、api，所有就需要用到 core.js 进行兼容性处理，从而解决问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue 代码配置</title>
      <link href="/2023/01/12/vue-%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/01/12/vue-%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Vetur"><a href="#Vetur" class="headerlink" title="Vetur"></a>Vetur</h2><p>vue2 代码提示插件<br>Vetur 支持.vue 文件的语法高亮显示，除了支持 template 模板以外，还支持大多数主流的前端开发脚本和插件，比如 Sass 和 TypeScript，对前端开发 vue 的小伙伴们非常友好</p><h2 id="vue-helper"><a href="#vue-helper" class="headerlink" title="vue-helper"></a>vue-helper</h2><p>vue2 代码提示插件</p><p>在 template 中点击 vue 组件，vue 变量，vue 方法时都可定位到对应的文件或位置，在点击 vue 组件时跳转到对应文件的前提是该组件是安装相对路径引入（即不支持别名引入），且组件名与组件的文件名一样。比如组件文件名是 select.vue,而引入组件时却是,这种情况不能点击，需把组件文件名改成 common-select.vue</p><h2 id="Vue-Language-Features-Volar"><a href="#Vue-Language-Features-Volar" class="headerlink" title="Vue Language Features (Volar)"></a>Vue Language Features (Volar)</h2><p>vue3 代码提示插件</p><h2 id="TypeScript-Vue-Plugin-Volar"><a href="#TypeScript-Vue-Plugin-Volar" class="headerlink" title="TypeScript Vue Plugin (Volar)"></a>TypeScript Vue Plugin (Volar)</h2><p>ts vu3 代码提示插件</p><h2 id="Vue-3-Snippets"><a href="#Vue-3-Snippets" class="headerlink" title="Vue 3 Snippets"></a>Vue 3 Snippets</h2><p>用于 vue3 的智能代码提示，语法高亮、智能感知、Emmet 等。替代 Vetur 插件，Vetur 在 vue2 时期比较流行</p><h2 id="在线代码片段格式化"><a href="#在线代码片段格式化" class="headerlink" title="在线代码片段格式化"></a>在线代码片段格式化</h2><p><a href="https://snippet-generator.app/">目标</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>element ui select 对象 多个参数问题</title>
      <link href="/2023/01/03/element-ui-select-%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98/"/>
      <url>/2023/01/03/element-ui-select-%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>//解决 select 选择对象问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">!&lt;template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-select v-model=&quot;selectedObject&quot; value-key=&quot;foodid&quot; placeholder=&quot;请选择&quot;&gt;</span><br><span class="line">    &lt;el-option</span><br><span class="line">      v-for=&quot;item in food&quot;</span><br><span class="line">      :key=&quot;item.foodid&quot;</span><br><span class="line">      :label=&quot;item.foodname&quot;</span><br><span class="line">      :value=&quot;item&quot;&gt;</span><br><span class="line">    &lt;/el-option&gt;</span><br><span class="line">&lt;/el-select&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        food: [&#123;</span><br><span class="line">          foodid: 1,</span><br><span class="line">          foodname: &#x27;黄金糕&#x27;</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          foodid: 2,</span><br><span class="line">          foodname: &#x27;双皮奶&#x27;</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">          foodid: 3,</span><br><span class="line">          foodname: &#x27;蚵仔煎&#x27;</span><br><span class="line">        &#125;],</span><br><span class="line"></span><br><span class="line">        selectedObject: &#123;</span><br><span class="line">          foodid: 0,</span><br><span class="line">          name: &#x27;&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>wget使用3</title>
      <link href="/2022/12/31/wget%E4%BD%BF%E7%94%A83/"/>
      <url>/2022/12/31/wget%E4%BD%BF%E7%94%A83/</url>
      
        <content type="html"><![CDATA[<p>一 wget简介<br>wget是linux上的命令行的下载工具。这是一个GPL许可证下的自由软件。wget支持HTTP和FTP协议，支持代理服务器和断点续传功能，能够自动递归远程主机的目录，找到合乎条件的文件并将其下载到本地硬盘上；如果必要，wget将恰当地转换页面中的超级连接以在本地生成可浏览的镜像。由于没有交互式界面，wget可在后台运行，截获并忽略HANGUP信号，因此在用户推出登录以后，仍可继续运行。通常，wget用于成批量地下载Internet网站上的文件，或制作远程网站的镜像。</p><p>二 实例</p><p>下载<br>下载192.168.1.168首页并且显示下载信息<br>wget -d <a href="http://192.168.1.168/">http://192.168.1.168</a></p><p>下载192.168.1.168首页并且不显示任何信息<br>wget -q <a href="http://192.168.1.168/">http://192.168.1.168</a></p><p>下载filelist.txt中所包含的链接的所有文件<br>wget -i filelist.txt</p><p>下载到指定目录<br>wget -P/tmp <a href="ftp://user:passwd@url/file">ftp://user:passwd@url/file</a><br>把文件file下载到/tmp目录下。</p><p>wget 是一个命令行的下载工具。对于我们这些 Linux 用户来说，几乎每天都在使用它。下面为大家介绍几个有用的 wget 小技巧，可以让你更加高效而灵活的使用 wget。</p><ul><li><p>$ wget -r -np -nd <a href="http://example.com/packages/">http://example.com/packages/</a><br>这条命令可以下载 <a href="http://example.com/">http://example.com</a> 网站上 packages 目录中的所有文件。其中，-np 的作用是不遍历父目录，-nd 表示不在本机重新创建目录结构。</p></li><li><p>$ wget -r -np -nd –accept=iso <a href="http://example.com/centos-5/i386/">http://example.com/centos-5/i386/</a><br>与上一条命令相似，但多加了一个 –accept=iso 选项，这指示 wget 仅下载 i386 目录中所有扩展名为 iso 的文件。你也可以指定多个扩展名，只需用逗号分隔即可。</p></li><li><p>$ wget -i filename.txt<br>此命令常用于批量下载的情形，把所有需要下载文件的地址放到 filename.txt 中，然后 wget 就会自动为你下载所有文件了。</p></li><li><p>$ wget -c <a href="http://example.com/really-big-file.iso">http://example.com/really-big-file.iso</a><br>这里所指定的 -c 选项的作用为断点续传。</p></li><li><p>$ wget -m -k (-H) <a href="http://www.example.com/">http://www.example.com/</a><br>该命令可用来镜像一个网站，wget 将对链接进行转换。如果网站中的图像是放在另外的站点，那么可以使用 -H 选项。</p></li></ul><p>三 参数<br>代码:<br>　　$ wget –help</p><p>　　GNU Wget 1.9.1，非交互式的网络文件下载工具。<br>　　用法： wget [选项]… [URL]…</p><p>　　长选项必须用的参数在使用短选项时也是必须的。</p><p>启动：<br>　　-V, –version 显示 Wget 的版本并且退出。<br>　　-h, –help 打印此帮助。<br>　　-b, -background 启动后进入后台操作。<br>　　-e, -execute=COMMAND 运行‘.wgetrc’形式的命令。</p><p>日志记录及输入文件：<br>　　-o, –output-file=文件 将日志消息写入到指定文件中。<br>　　-a, –append-output=文件 将日志消息追加到指定文件的末端。<br>　　-d, –debug 打印调试输出。<br>　　-q, –quiet 安静模式(不输出信息)。<br>　　-v, –verbose 详细输出模式(默认)。<br>　　-nv, –non-verbose 关闭详细输出模式，但不进入安静模式。<br>　　-i, –input-file=文件 下载从指定文件中找到的 URL。<br>　　-F, –force-html 以 HTML 方式处理输入文件。<br>　　-B, –base=URL 使用 -F -i 文件选项时，在相对链接前添加指定的 URL。</p><p>下载：<br>　　-t, –tries=次数 配置重试次数（0 表示无限）。<br>　　–retry-connrefused 即使拒绝连接也重试。<br>　　-O –output-document=文件 将数据写入此文件中。<br>　　-nc, –no-clobber 不更改已经存在的文件，也不使用在文件名后添加 .#（# 为数字）的方法写入新的文件。<br>　　-c, –continue 继续接收已下载了一部分的文件。<br>　　–progress=方式 选择下载进度的表示方式。<br>　　-N, –timestamping 除非远程文件较新，否则不再取回。<br>　　-S, –server-response 显示服务器回应消息。<br>　　–spider 不下载任何数据。<br>　　-T, –timeout=秒数 配置读取数据的超时时间 (秒数)。<br>　　-w, –wait=秒数 接收不同文件之间等待的秒数。<br>　　–waitretry=秒数 在每次重试之间稍等一段时间 (由 1 秒至指定的 秒数不等)。<br>　　–random-wait 接收不同文件之间稍等一段时间(由 0 秒至 2*WAIT 秒不等)。<br>　　-Y, –proxy=on/off 打开或关闭代理服务器。<br>　　-Q, –quota=大小 配置接收数据的限额大小。<br>　　–bind-address=地址 使用本机的指定地址 (主机名称或 IP) 进行连接。<br>　　–limit-rate=速率 限制下载的速率。<br>　　–dns-cache=off 禁止查找存于高速缓存中的 DNS。<br>　　–restrict-file-names=OS 限制文件名中的字符为指定的 OS (操作系统) 所允许的字符。</p><p>目录：<br>　　-nd –no-directories 不创建目录。<br>　　-x, –force-directories 强制创建目录。<br>　　-nH, –no-host-directories 不创建含有远程主机名称的目录。<br>　　-P, –directory-prefix=名称 保存文件前先创建指定名称的目录。<br>　　–cut-dirs=数目 忽略远程目录中指定数目的目录层。</p><p>HTTP 选项：<br>　　–http-user=用户 配置 http 用户名。<br>　　–http-passwd=密码 配置 http 用户密码。<br>　　-C, –cache=on/off (不)使用服务器中的高速缓存中的数据 (默认是使用的)。<br>　　-E, –html-extension 将所有 MIME 类型为 text/html 的文件都加上 .html 扩展文件名。<br>　　–ignore-length 忽略“Content-Length”文件头字段。<br>　　–header=字符串 在文件头中添加指定字符串。<br>　　–proxy-user=用户 配置代理服务器用户名。<br>　　–proxy-passwd=密码 配置代理服务器用户密码。<br>　　–referer=URL 在 HTTP 请求中包含“Referer：URL”头。<br>　　-s, –save-headers 将 HTTP 头存入文件。<br>　　-U, –user-agent=AGENT 标志为 AGENT 而不是 Wget/VERSION。<br>　　–no-http-keep-alive 禁用 HTTP keep-alive（持久性连接）。<br>　　–cookies=off 禁用 cookie。<br>　　–load-cookies=文件 会话开始前由指定文件载入 cookie。<br>　　–save-cookies=文件 会话结束后将 cookie 保存至指定文件。<br>　　–post-data=字符串 使用 POST 方法，发送指定字符串。<br>　　–post-file=文件 使用 POST 方法，发送指定文件中的内容。</p><p>HTTPS (SSL) 选项：<br>　　–sslcertfile=文件 可选的客户段端证书。<br>　　–sslcertkey=密钥文件 对此证书可选的“密钥文件”。<br>　　–egd-file=文件 EGD socket 文件名。<br>　　–sslcadir=目录 CA 散列表所在的目录。<br>　　–sslcafile=文件 包含 CA 的文件。<br>　　–sslcerttype=0/1 Client-Cert 类型 0=PEM (默认) / 1=ASN1 (DER)<br>　　–sslcheckcert=0/1 根据提供的 CA 检查服务器的证书<br>　　–sslprotocol=0-3 选择 SSL 协议；0=自动选择，<br>　　1=SSLv2 2=SSLv3 3=TLSv1</p><p>FTP 选项：<br>　　-nr, –dont-remove-listing 不删除“.listing”文件。<br>　　-g, –glob=on/off 设置是否展开有通配符的文件名。<br>　　–passive-ftp 使用“被动”传输模式。<br>　　–retr-symlinks 在递归模式中，下载链接所指示的文件(连至目录则例外）。</p><p>递归下载：<br>　　-r, –recursive 递归下载。<br>　　-l, –level=数字 最大递归深度(inf 或 0 表示无限)。<br>　　–delete-after 删除下载后的文件。<br>　　-k, –convert-links 将绝对链接转换为相对链接。<br>　　-K, –backup-converted 转换文件 X 前先将其备份为 X.orig。<br>　　-m, –mirror 等效于 -r -N -l inf -nr 的选项。<br>　　-p, –page-requisites 下载所有显示完整网页所需的文件，例如图像。<br>　　–strict-comments 打开对 HTML 备注的严格(SGML)处理选项。</p><p>递归下载时有关接受/拒绝的选项：<br>　　-A, –accept=列表 接受的文件样式列表，以逗号分隔。<br>　　-R, –reject=列表 排除的文件样式列表，以逗号分隔。<br>　　-D, –domains=列表 接受的域列表，以逗号分隔。<br>　　–exclude-domains=列表 排除的域列表，以逗号分隔。<br>　　–follow-ftp 跟随 HTML 文件中的 FTP 链接。<br>　　–follow-tags=列表 要跟随的 HTML 标记，以逗号分隔。<br>　　-G, –ignore-tags=列表 要忽略的 HTML 标记，以逗号分隔。<br>　　-H, –span-hosts 递归时可进入其它主机。<br>　　-L, –relative 只跟随相对链接。<br>　　-I, –include-directories=列表 要下载的目录列表。<br>　　-X, –exclude-directories=列表 要排除的目录列表。<br>　　-np, –no-parent 不搜索上层目录。</p><p>四 FQA<br>A.使用wget工具<br>linux所以的主要版本都自带了wget这个下载工具.<br>bash$ wget <a href="http://place.your.url/here">http://place.your.url/here</a></p><p>它还能控制ftp来下载整个web站点的各级目录,当然,如果你不小心,可能会把整个网站以及其他和他做链接的网站全部下载下来.<br>bash$ wget -m <a href="http://target.web.site/subdirectory">http://target.web.site/subdirectory</a></p><p>由于这个工具具有很强的下载能力,所以可以在服务器上把它用作镜像网站的工具.让它按照”robots.txt”的规定来执行.<br>有很多参数用来控制它如何正确地做镜像,可以限制链接的类型和下载文件的类型等等.例如:只下载有联系的链接并且忽略GIF图片:<br>bash$ wget -m -L –reject=gif <a href="http://target.web.site/subdirectory">http://target.web.site/subdirectory</a></p><p>wget也能够实现断点续传(-c参数),当然,这种操作是需要远程服务器支持的.<br>bash$ wget -c <a href="http://the.url.of/incomplete/file">http://the.url.of/incomplete/file</a></p><p>可以把断点续传和镜像功能结合起来,这样可以在以前断过多次的情况下继续镜像一个有大量选择性文件的站点.如何自动实现这个目的我们在后面会讨论得更多.<br>如果你觉得下载时老是断线会影响你办公的话,你可以限制wget重试的次数.<br>bash$ wget -t 5 <a href="http://place.your.url/here">http://place.your.url/here</a><br>这样重试五次后就放弃了.用”-t inf”参数表示永远不放弃.不停地重试.</p><p>B．那对于代理服务该怎么办呢?<br>可以使用http代理的参数或者在.wgetrc配置文件里指定一个如何通过代理去下载的途径.但是有这么一个问题,如果通过代理来进行断点续传的话可能会有几次失败.如果有一次通过代理下载的过程发生中断,那么代理服务器上缓存里保存是那个完整的文件拷贝. 所以当你用”wget -c”来下载剩余部分的时候代理服务器查看它的缓存,并错误地认为你已经下载了整个文件.于是就发出了错误的信号.这个时候你可以用添加一个特定的请求参数来促使代理服务器清除他们的缓存:<br>bash$ wget -c –header=”Pragma: no-cache” <a href="http://place.your.url/here">http://place.your.url/here</a></p><p>这个”–header”参数能够以各种数字，各种方式添加。通过它我们可以更改web服务器或者代理服务器的某些属性。有些站点不提供外部连接的文件服务，只有通过同一个站点上其他的一些页面时内容才会被提交。这个时候你可以用加上”Referer:”参数：<br>bash$ wget –header=”Referer: <a href="http://coming.from.this/page%E2%80%9D">http://coming.from.this/page”</a> <a href="http://surfing.to.this/page">http://surfing.to.this/page</a><br>有些特殊的网站只支持某种特定的浏览器，这个时候可以用”User-Agent:”参数<br>bash$ wget –header=”User-Agent: Mozilla/4.0 (compatible; MSIE 5.0;Windows NT; DigExt)” <a href="http://msie.only.url/here">http://msie.only.url/here</a></p><p>C．那我怎么设定下载时间呢？<br>如果你需要在你的办公电脑上通过和其他同事共享的一个连接来下载一些很大的文件，而且你希望你的同事不会因为网络速度的减慢而收到影响，那你就应该尽量避开高峰时段。当然,不需要在办公室里等到所以人都走掉，也不需要在家里用完晚饭后还惦记着要上网下载一次。<br>用at来就可以很好的定制工作时间：<br>bash$ at 23：00<br>warning: commands will be executed using /bin/sh<br>at&gt; wget <a href="http://place.your.url/here">http://place.your.url/here</a><br>at&gt; press Ctrl-D<br>这样，我们设定了下载工作在晚上11点进行。为了使这个安排能够正常进行，请确<br>认atd这个后台程序正在运行。</p><p>D．下载要花很多时间？<br>当你需要下载大量的数据，而且你又没有享有足够的带宽,这个时候你会经常发现在你安排的下载任务还没有完成，一天的工作却又要开始了。<br>作为一个好同事，你只能停掉了这些任务，而开始另外的工作。然后你又需要反复地重复使用”wget -c”来完成你的下载。这样肯定太繁琐了，所以最好是用crontab来自动执行。创建一个纯文本文件，叫做”crontab.txt”,包含下面的内容：<br>0 23 * * 1-5 wget -c -N <a href="http://place.your.url/here">http://place.your.url/here</a><br>0 6 * * 1-5 killall wget<br>这个crontab文件指定某些任务定期地执行。前五列声明是什么时候执行这个命令，而每行的剩余部分则告诉crontab执行什么内容。<br>前两列指定了每天一到晚上11点就开始用wget下载，一到早上6点就停止一切wget下载。第三四列的*表示每个月的每一天都执行这个任务。第五列则指定了一个星期的哪几天来执行这个程序。 –”1-5″表示从星期一到星期五。</p><p>这样在每个工作日的晚上11点，下载工作开始，到了上午的6点，任何的wget任务就被停掉了。你可以用下面的命令来执行crontab：bash$ crontab crontab.txt<br>wget的这个”-N”参数将会检查目标文件的时间戳，如果匹配了，下载程序就会停止，因为它说明整个文件已经下载完全了。<br>用”crontab -r”可以删除这个计划安排。我已经多次采用这种方法，通过共享的电话拨号来下载过很多的ISO镜像文件,还是比较实用的。</p><p>E．如何下载动态变化的网页<br>有些网页每天都要根据要求变化好几次.所以从技术上讲,目标不再是一个文件,它没有文件长度.因此”-c”这个参数也就失去了意义.<br>例如:一个PHP写的并且经常变动的linux周末新闻网页:<br>bash$ wget <a href="http://lwn.net/bigpage.php3">http://lwn.net/bigpage.php3</a></p><p>我办公室里的网络条件经常很差,给我的下载带了很大的麻烦,所以我写了个简单的脚本来检测动态页面是否已经完全更新了.<br>#!/bin/bash<br>#create it if absent<br>touch bigpage.php3<br>#check if we got the whole thing<br>while ! grep -qi bigpage.php3<br>do<br>rm -f bigpage.php3<br>#download LWN in one big page<br>wget <a href="http://lwn.net/bigpage.php3">http://lwn.net/bigpage.php3</a><br>done<br>这个脚本能够保证持续的下载该网页,直到网页里面出现了” “,这就表示该文件已经完全更新了.</p><p>F．对于ssl和Cookies怎么办？<br>如果你要通过ssl来上网,那么网站地址应该是以”https://”来开头的.在这样的情况下你就需要另外一种下载工具,叫做curl，它能够很容易获得.有些网站迫使网友在浏览的时候必须使用cookie.所以你必须从在网站上得到的那个 Cookie里面得到”Cookie:”这个参数.这样才<br>能保证下载的参数正确.对于lynx和Mozilla的Cookie的文件格式,用下面的:<br>bash$ cookie=$( grep nytimes ~/.lynx_cookies |awk {printf(”%s=%s;”,$6,$7)} )<br>就可以构造一个请求Cookie来下载<a href="http://www.nytimes.com上的内容.当然,你要已经用这个浏览器在该网站上完成注册/">http://www.nytimes.com上的内容.当然,你要已经用这个浏览器在该网站上完成注册</a>.<br>w3m使用了一种不同的,更小巧的Cookie文件格式:<br>bash$ cookie=$( grep nytimes ~/.w3m/cookie |awk {printf(”%s=%s;”,$2,$3)} )<br>现在就可以用这种方法来下载了:<br>bash$ wget –header=”Cookie: $cookie” <a href="http://www.nytimes.com/reuters/technology/tech-tech-supercomput.html">http://www.nytimes.com/reuters/technology/tech-tech-supercomput.html</a><br>或者用curl工具:<br>bash$ curl -v -b $cookie -o supercomp.html <a href="http://www.nytimes.com/reuters/technology/tech-tech-supercomput.htm">http://www.nytimes.com/reuters/technology/tech-tech-supercomput.htm</a></p><p>G．如何建立地址列表？<br>到现在为止我们下载的都是单个文件或者是整个网站.有的时候我们需要下载某个网页上链接的大量文件,但没有必要把它整个网站都镜像下来.比如说我们想从一个依次排列的100首歌里面下载前20首.注意,这里”–accept”和”–reject”参数是不会起作用的, 因为他们只对文件操作起作用.所以一定要用”lynx -dump”参数来代替.<br>bash$ lynx -dump <a href="ftp://ftp.ssc.com/pub/lg/">ftp://ftp.ssc.com/pub/lg/</a> |grep gz$ |tail -10 |awk {print $2} &gt; urllist.txt<br>lynx的输出结果可以被各种GNU文本处理工具过虑.在上面的例子里,我们的链接地址是以”gz”结尾的,并且把最后10个文件地址放到urllist.txt文件里.然后我们可以写一个简单的bash脚本来自动下载这个文件里的目标文件:<br>bash$ for x in $(cat urllist.txt)</p><blockquote><p>do<br>wget $x<br>done<br>这样我们就能够成功下载Linux Gazette网站(<a href="ftp://ftp.ssc.com/pub/lg/)%E4%B8%8A%E7%9A%84%E6%9C%80%E6%96%B010%E4%B8%AA%E8%AE%BA%E9%A2%98">ftp://ftp.ssc.com/pub/lg/)上的最新10个论题</a>.</p></blockquote><p>H．扩大使用的带宽<br>如果你选择下载一个受带宽限制的文件,那你的下载会因为服务器端的限制而变得很慢.下面这个技巧会大大缩短下载的过程.但这个技巧需要你使用curl并且远程服务器有多个镜像可以供你下载.例如,假设你想从下面的三个地址下载Mandrake 8.0:<br>url1=<a href="http://ftp.eecs.umich.edu/pub/linux/mandrake/iso/Mandrake80-inst.iso">http://ftp.eecs.umich.edu/pub/linux/mandrake/iso/Mandrake80-inst.iso</a><br>url2=<a href="http://ftp.rpmfind.net/linux/Mandrake/iso/Mandrake80-inst.iso">http://ftp.rpmfind.net/linux/Mandrake/iso/Mandrake80-inst.iso</a><br>url3=<a href="http://ftp.wayne.edu/linux/mandrake/iso/Mandrake80-inst.iso">http://ftp.wayne.edu/linux/mandrake/iso/Mandrake80-inst.iso</a><br>这个文件的长度是677281792个字节,所以用curl程序加”–range”参数来建立三个同时进行的下载:<br>bash$ curl -r 0-199999999 -o mdk-iso.part1 $url1 &amp;<br>bash$ curl -r 200000000-399999999 -o mdk-iso.part2 $url2 &amp;<br>bash$ curl -r 400000000- -o mdk-iso.part3 $url3 &amp;<br>这样就创建了三个后台进程.每个进程从不同的服务器传输这个ISO文件的不同部分.这个”-r”参数指定目标文件的字节范围.当这三个<br>进程结束后,用一个简单的cat命令来把这三个文件衔接起来– cat mdk-iso.part? &gt; mdk-80.iso.(强烈建议在刻盘之前先检查md5)<br>你也可以用”–verbose”参数来使每个curl进程都有自己的窗口来显示传输的过程.</p><p>完！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>wget使用2</title>
      <link href="/2022/12/31/wget%E4%BD%BF%E7%94%A82/"/>
      <url>/2022/12/31/wget%E4%BD%BF%E7%94%A82/</url>
      
        <content type="html"><![CDATA[<p>wget是Linux中的一个下载文件的工具，wget是在Linux下开发的开放源代码的软件，作者是Hrvoje Niksic，后来被移植到包括Windows在内的各个平台上。</p><p>它用在命令行下。对于Linux用户是必不可少的工具，尤其对于网络管理员，经常要下载一些软件或从远程服务器恢复备份到本地服务器。如果我们使用虚拟主机，处理这样的事务我们只能先从远程服务器下载到我们电脑磁盘，然后再用ftp工具上传到服务器。这样既浪费时间又浪费精力，那不没办法的事。而到了Linux VPS，它则可以直接下载到服务器而不用经过上传这一步。wget工具体积小但功能完善，它支持断点下载功能，同时支持FTP和HTTP下载方式，支持代理服务器和设置起来方便简单。下面我们以实例的形式说明怎么使用wget。</p><p>1、使用 wget 下载单个文件</p><p>以下的例子是从网络下载一个文件并保存在当前目录</p><p>在下载的过程中会显示进度条，包含（下载完成百分比，已经下载的字节，当前下载速度，剩余下载时间）</p><p>2、使用 wget -O 下载并以不同的文件名保存</p><p>我们可以使用参数-O来指定一个文件名：</p><p>3、使用 wget -c 断点续传</p><p>使用wget -c重新启动下载中断的文件:</p><p>对于我们下载大文件时突然由于网络等原因中断非常有帮助，我们可以继续接着下载而不是重新下载一个文件</p><p>4、使用 wget -b 后台下载</p><p>对于下载非常大的文件的时候，我们可以使用参数-b进行后台下载</p><p>你可以使用以下命令来察看下载进度</p><p>5、使用 wget –spider 测试下载链接</p><p>当你打算进行定时下载，你应该在预定时间测试下载链接是否有效。我们可以增加–spider参数进行检查。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>windows.jQuery ||document.write是什么意思</title>
      <link href="/2022/12/31/windows-jQuery-document-write%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/"/>
      <url>/2022/12/31/windows-jQuery-document-write%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/</url>
      
        <content type="html"><![CDATA[<p>“window.jQuery || document.write”经常用到这句代码是什么意思<br>2020-07-03 13:08:33字体：大 中 小来源：转载供稿：网友<br>这篇文章主要为大家详细介绍了“window.jQuery || document.write”经常用到这句代码是什么意思，具有一定的参考价值，感兴趣的小伙伴们可以参考一下,有需要的朋友可以收藏方便以后借鉴。<br>我们在使用JQ特效的时候，很多时候会有这样一句话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;window.jQuery || document.write(&#x27;&lt;script src=&quot;js/jquery-1.11.0.min.js&quot;&gt;&lt;//script&gt;&#x27;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>很多朋友可能不太能理解这句代码是什么意思。其实很简单，一般在这里个文件上边的<script>应该是有一个通过cdn加载文件jquery-1.11.0.min.js的路径，这里就是上边的路径不能加载文件的时候，使用下边的本地文件，一种优化响应的策略。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://cdn.bootcss.com/jquery/1.11.0/jquery.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;window.jQuery || document.write(&#x27;&lt;script src=&quot;js/jquery-1.11.0.min.js&quot;&gt;&lt;//script&gt;&#x27;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>下面的语句就是首先会判断有没有window.jQuery，即判断是否导入了jquery,如果没有（也就是false）,则运行后面的代码，将jquery引入到项目中。</p><p>||逻辑判断的规则：如果||前面的表达式是true,就返回||前面表达式true的结果，如果是false,则运行后面的表达式。</p><p>现在明白了没有，说白了就是下面的语句是防止上面的JQ引入失败，不成功的时候启用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Bulma</title>
      <link href="/2022/12/31/Bulma/"/>
      <url>/2022/12/31/Bulma/</url>
      
        <content type="html"><![CDATA[<p>或许你之前听说过Bulma；如果没有，也没关系。Bulma是一个轻量级、可配置的CSS框架。<br>​​</p><p>或许你之前听说过Bulma；如果没有，也没关系。如前所述，Bulma是一个轻量级、可配置的CSS框架，完全基于Flexbox。Flexbox是一个相对较新的CSS规范，在本书编写时，它得到了浏览器的良好支持。</p><p>Bulma底层使用Flexbox来运行，并帮助你解决了使用Flexbox时需要考虑的难点。使用Bulma无须了解Flexbox，但应掌握基本的CSS知识。</p><p>本文将从较高的层次介绍Bulma，带你熟悉Bulma及其术语和概念，本文节选自图书《Bulma必知必会》。</p><p>1.1　Bulma有何独特之处</p><p>与其他CSS框架相比，Bulma有如下不同之处。</p><p>现代化：整个Bulma是基于CSS Flexbox设计的。<br>响应式：Bulma的设计同时支持移动端和桌面设备。<br>易学：大多数用户只需几分钟便能入门。<br>语法简单：Bulma使用更少的HTML，所以代码易于阅读和编写。<br>可定制：Bulma提供了300多个SASS变量，基于这些样式变量，你可以定制自己的主题框架。<br>无JavaScript：Bulma完全基于CSS设计编写，因此可以很优雅地与任何JavaScript框架（Angular、Vue.js、React、Ember或者纯JavaScript应用）集成。</p><p>1.2　简易的栅格系统</p><p>Bulma最著名的当属其简单明了的栅格架构：</p><p>就是这样，只需两个CSS类（columns 作为容器类，column作为其子类），即可实现响应式栅格系统，无须指定其他任何维度，两列会自动分占宽度的50%。</p><p>如果想要第3列，只需再添加一个 column 即可：</p><p>每一列会自动占据33% 的宽度，无须编写额外的代码。如果想要更多列，按上述操作添加</p><p>column</p><p>即可实现，Bulma会帮你自动适配大小。</p><p>1.3　可读性</p><p>Bulma简单易学，因为它的代码简洁易读。下面是一个Bulma按钮的代码，仅需添加一个button类即可实现。</p><p>为了扩展该按钮的功能，Bulma提供了修饰符类，用于给基础的按钮提供其他样式。要对该按钮应用主色调青绿色，并增大尺寸，只需添加 is-primary 类和 is-large 类：​</p><p>提示：最好使用“primary”“secondary”这样的主次命名约定。这将有助于给样式赋予一些意义，并为以后的定制留有余地。</p><p>1.4　可定制</p><p>Bulma有300多个变量，几乎可以覆盖Bulma中的所有属性，因此可以高度定义个性化设置。</p><p>使用SASS，可以设置初始变量，比如覆盖 blue 的颜色值、设置默认字体甚至各种响应式断点。</p><p>每一个Bulma组件都有自己的变量集合：</p><p>box组件具有阴影；<br>columns有默认空白；<br>menu有默认的背景色和前景色；<br>button和input的每一种状态（悬浮、活跃、选中）都有对应颜色；<br>……<br>每个文档页面都有可覆盖的变量列表。</p><p>1.5　模块化</p><p>由于Bulma被划分成了多个模块文件，所以按需导入相应代码即可。</p><p>例如，有的开发人员只想使用Bulma的栅格系统，那么创建一个如下所示的SASS文件即可。</p><p>上述 SASS 文件只引入了 Bulma 的 columns 和 column CSS类。</p><p>1.6　列</p><p>Flexbox是一维的栅格系统，这意味着在Bulma中有行或者列的概念。使用Bulma开发网站要考虑列，并将列封装在行或容器中。Bulma的基本功能如下。</p><p>从 columns 行开始。</p><p>在 columns 行中，可以添加一列或者多列，Bulma会基于添加的列计算每列所占空间。​</p><p>在这个例子中，添加的 column 占据了整个浏览器的宽度，因为在 columns 中仅此一列。</p><p>如前所述，每一列的宽度并不固定，但还是要再次强调：添加的列越多，每一列就会越窄，比如有3列，每一列的宽度就是33%；如果是4列，每一列的宽度就是25%。</p><p>1.7　修饰符</p><p>修饰符是额外的CSS类，可以把它们添加到HTML中，以此改变HTML元素的显示效果。以按钮（<button>）为例，通过给它添加修饰符来更改显示效果，如下所示。</p><p>该按钮只是一个简单的通用按钮，下面把它变成Bulma内置的青绿色按钮样式。为了把它的颜色改为主色调，可以给它添加is-primary修饰符。​</p><p>现在按钮变成青绿色了！再给它添加一个“幽灵”按钮的修饰符，让它呈现镂空效果。​</p><p>也可以添加一个 is-loading 修饰符来给按钮增加一个加载中的动画效果，表示某种进行中的状态，比如表单提交流程。</p><p>同样值得注意的是，在添加自定义类之前，尽量利用Bulma现有的类是最佳实践。如果覆盖了某些元素的样式，请继续使用现有的类。</p><p>1.8　组件</p><p>Bulma提供了许多可用的组件。组件是用于实现特定功能模块的代码片段。如果基于这些组件来实现功能，必须按照组件的对外接口格式编写代码。</p><p>有关组件的更多信息和示例，请参见Bulma的组件文档。</p><p>如下是一个卡片组件的示例：</p><p>Bulma还提供了其他组件，比如菜单、下拉菜单、消息提示、模态框等。</p><p>1.9　辅助类</p><p>辅助类（也称工具类）是用于辅助布局的修饰符。它们与传统修饰符的区别是，修饰符是用于改变组件或者元素的视觉效果的，而辅助类是用于处理元素定位的。</p><p>下面是一些常用的辅助类。</p><p>is-marginless：移除当前元素的所有外边距。<br>is-unselectable：使当前文本处于不可选择状态。<br>is-pulled-left ：使得当前的元素靠左布局。</p><p>除上述辅助类外，还有用于响应式和排版的辅助类，可帮助用户更好地实现响应式和文字排版。</p><p>一本书掌握 Bulma</p><p>让你用更少CSS的代码实现更多功能</p><p>《Bulma必知必会》</p><p>杰里米 · 托马斯等 著</p><p>华华 , 张俊达  译</p><p>Bulma 是一个流行的开源 CSS 框架，轻量而易用。借助它，即使完全不会编写CSS，也能轻松创建出美观的网页。本书通过生动实例细致讲解如何使用Bulma 框架从头创建 Web 应用。</p><p>主要内容包括：Bulma 的基本概念与特性，如何用 Bulma 创建页面布局，Bulma 组件如何工作，如何设计具体的 UI 元素，如何将 Bulma 嵌入JavaScript，如何将 Bulma 与流行的前端框架 React、Angular 和 Vue 集成，等等。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>A标签学习</title>
      <link href="/2022/12/30/A%E6%A0%87%E7%AD%BE%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/12/30/A%E6%A0%87%E7%AD%BE%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>一、a 标签的定义、属性和格式<br> <a> 标签定义超链接，用于从一张页面链接到另一张页面，其最重要的属性是 href 属性，它指示链接的目标。</p><p>常用的属性，且 H5 支持：</p><pre><code>              1）href：谷底那个链接指向的页面的URL；              2）target：规定在何处打开链接文档；     格式：&lt;a href=&quot;#&quot; target=&quot;&quot;&gt;超链接&lt;/a&gt;</code></pre><p>二、href 中#和 javascript:void(0)的理解<br>① a href =” “:<br>默认打开的还是当前页面，会刷新一下重新打开。<br>② a href =”#”:<br>浏览器地址栏网址后面会多显示 1 个#。不会刷新页面，会回到页面顶部。点击之后会自动跳转到页面的最上面，因为用了这个方法就相当于点击了一个锚记，但是这个锚记又没写 ID，所以就默认跳转到页面顶部。<br>③ a href =”Javascript: void(0) “:<br>void 是一个操作符，这个操作符指定要计算一个表达式但是不返回值。如果在 void 中写入 0（void(0)），则什么也不执行，从而也就形成了一个死链接，默认阻止，不进行动作。<br>&lt;a href=”javascript:void(0);” οnclick=function() &gt;。onclick 会先于 href 执行。<br>三、target 详解<br>有 4 个保留的目标名称用作特殊的文档重定向操作：<br>①_blank<br>浏览器总在一个新打开、未命名的窗口中载入目标文档。<br>②_self<br>这个目标的值对所有没有指定目标的 <a> 标签是默认目标，它使得目标文档载入并显示在相同的框架或者窗口中作为源文档。这个目标是多余且不必要的，除非和文档标题 <base> 标签中的 target 属性一起使用。<br>③_parent<br>这个目标使得文档载入父窗口或者包含来超链接引用的框架的框架集。如果这个引用是在窗口或者在顶级框架中，那么它与目标 _self 等效。<br>④_top<br>这个目标使得文档载入包含这个超链接的窗口，用 _top 目标将会清除所有被包含的框架并将文档载入整个浏览器窗口。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>彻底弄懂 Javascript 模块导入导出</title>
      <link href="/2022/12/30/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82-Javascript-%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"/>
      <url>/2022/12/30/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82-Javascript-%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>笔者开始学习 Javascript 的时候，对模块不太懂，不知道怎么导入模块，导出模块，就胡乱一通试</p><p>比如 import xx from ‘test.js’ 不起作用，就加个括号 import {xx} from ‘test.js’</p><p>反正总是靠蒙，总有一种写法是对的，其实还是没有理解，还是不懂</p><p>尤其是在当初写 <a href="http://www.helloworld.net/">www.helloworld.net</a> 网站的时候，一遇到这种问题，就懵逼了，尤其是引入第三方库的时候</p><p>这种情况下更多，此篇文章也是为了怕以后忘记，自查用的，也希望能帮助更多的朋友，此篇文章只是针对 ES6 的模块相关知识</p><hr><p>首先要知道 export，import 是什么</p><p>我们知道，JS 模块导入导出，使用 import , export 这两个关键字</p><p>export 用于对外输出本模块<br>import 用于导入模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也就是说使用 export 导出一个模块之后，其它文件就可以使用 import 导入相应的模块了</span><br></pre></td></tr></table></figure><p>下面我们具体看看， import 和 export 到底怎么用？怎么导出模块（比如变量，函数，类，对象等）</p><hr><p>1 导出单个变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//a.js 导出一个变量，语法如下</span><br><span class="line">export var site = &quot;www.helloworld.net&quot;</span><br><span class="line"></span><br><span class="line">//b.js 中使用import 导入上面的变量</span><br><span class="line">import &#123; site &#125; from &quot;/.a.js&quot; //路径根据你的实际情况填写</span><br><span class="line">console.log(site)//输出： www.helloworld.net</span><br></pre></td></tr></table></figure><hr><p>2 导出多个变量<br>上面的例子是导出单个变量，那么如何导出多个变量呢</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//a.js 中定义两个变量，并导出</span><br><span class="line">var siteUrl=&quot;www.helloworld.net&quot;</span><br><span class="line">var siteName=&quot;helloworld开发者社区&quot;</span><br><span class="line"></span><br><span class="line">//将上面的变量导出</span><br><span class="line">export &#123; siteUrl ,siteName &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// b.js 中使用这两个变量</span><br><span class="line">import &#123; siteUrl , siteName &#125; from &quot;/.a.js&quot; //路径根据你的实际情况填写</span><br><span class="line"></span><br><span class="line">console.log(siteUrl)//输出： www.helloworld.net</span><br><span class="line">console.log(siteName)//输出： helloworld开发者社区</span><br></pre></td></tr></table></figure><p>3 导出函数<br>导出函数和导出变量一样，需要添加 { }</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//a.js 中定义并导出一个函数</span><br><span class="line">function sum(a, b) &#123;</span><br><span class="line">   return a + b</span><br><span class="line">&#125;</span><br><span class="line">//将函数sum导出</span><br><span class="line">export &#123; sum &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//b.js 中导入函数并使用</span><br><span class="line">import &#123; sum &#125; from &quot;/.a.js&quot; //路径根据你的实际情况填写</span><br><span class="line">console.log( sum(4,6) ) //输出： 10</span><br></pre></td></tr></table></figure><p>4 导出对象<br>js 中一切皆对象，所以对象一定是可以导出的，并且有两种写法</p><p>4.1 第一种写法<br>使用 export default 关键字导出，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//a.js 中，定义对象并导出, 注意，使用export default 这两个关键字导出一个对象</span><br><span class="line">export default &#123;</span><br><span class="line">    siteUrl:&#x27;www.helloworld.net&#x27;,</span><br><span class="line">    siteName:&#x27;helloworld开发者社区&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//b.js 中导入并使用</span><br><span class="line">import obj from &#x27;./a.js&#x27;   //路径根据你的实际情况填写</span><br><span class="line">console.log(obj.siteUrl)//输出：www.helloworld.net</span><br><span class="line">console.log(obj.siteName)//输出：helloworld开发者社区</span><br></pre></td></tr></table></figure><p>4.2 第二种写法<br>同样是使用 export default 关键字，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//a.js 中定义对象，并在最后导出</span><br><span class="line">var obj = &#123;</span><br><span class="line">   siteUrl:&#x27;www.helloworld.net&#x27;,</span><br><span class="line">    siteName:&#x27;helloworld开发者社区&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default obj//导出对象obj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//b.js 中导入并使用</span><br><span class="line">import obj from &#x27;./a.js&#x27;   //路径根据你的实际情况填写</span><br><span class="line">console.log(obj.siteUrl)//输出：www.helloworld.net</span><br><span class="line">console.log(obj.siteName)//输出：helloworld开发者社区</span><br></pre></td></tr></table></figure><p>5 导出类<br>导出类与上面的导出对象类似，同样是用 export default 关键字，同样有两种写法</p><p>5.1 第一种写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//a.js 中定义一个类并直接导出</span><br><span class="line">export default class Person &#123;</span><br><span class="line">    //类的属性</span><br><span class="line">    site = &quot;www.helloworld.net&quot;</span><br><span class="line"></span><br><span class="line">    //类的方法</span><br><span class="line">    show()&#123;</span><br><span class="line">        console.log(this.site)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//b.js 中导入并使用</span><br><span class="line">//导入类</span><br><span class="line">import Person from &#x27;./a.js&#x27;</span><br><span class="line"></span><br><span class="line">//创建类的一个对象person</span><br><span class="line">let person = new Person()</span><br><span class="line"></span><br><span class="line">//调用类的方法</span><br><span class="line">person.show()  //输出：www.helloworld.net</span><br></pre></td></tr></table></figure><p>5.2 第二种写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//a.js 中定义一个类，最后导出</span><br><span class="line">class Person &#123;</span><br><span class="line">    //类的属性</span><br><span class="line">    site = &quot;www.helloworld.net&quot;</span><br><span class="line"></span><br><span class="line">    //类的方法</span><br><span class="line">    show()&#123;</span><br><span class="line">        console.log(this.site)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//导出这个类</span><br><span class="line">export default Person</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//b.js 中导入并使用</span><br><span class="line">//导入类</span><br><span class="line">import Person from &#x27;./a.js&#x27;</span><br><span class="line"></span><br><span class="line">//创建类的一个对象person</span><br><span class="line">let person = new Person()</span><br><span class="line"></span><br><span class="line">//调用类的方法</span><br><span class="line">person.show()  //输出：www.helloworld.net</span><br></pre></td></tr></table></figure><hr><p>小结<br>下面我们简单总结一下<br>export 与 export default 的区别<br>·export 与 export default 均可用于导出常量、函数、文件、模块等<br>·可以在其它文件或模块中通过 import+(常量 | 函数 | 文件 | 模块) 名的方式，将其导入，以便能够对其进行使用<br>·export default 后面不能跟 const 或 let 的关键词<br>·export、import 可以有多个，export default 仅有一个。<br>·通过 export 方式导出，在导入时要加 { }，export default 则不需要<br>·export 具名导出 xxx ，export default 匿名。区别在于导入的时候，export 需要一样的名称才能匹配，后者无论取什么名都可以。<br>·模块化管理中一个文件就是一个模块，export 可以导出多个方法和变量，export default 只能导出当前模块，一个 js ·文件中只支持出现一个</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客语言学习</title>
      <link href="/2022/12/30/%E5%8D%9A%E5%AE%A2%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/12/30/%E5%8D%9A%E5%AE%A2%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>A 标签跳转<br><a href="https://www.baidu.com/">去百度</a></p><p>显示图片<br><img src="https://tangjiusheng.com/d/file/p/2022/11-01/ea0020e59fd64ddc68dd1ed164cd7cba.jpg?image_process=resize,p_80" alt="复制的图片"></p><p>一段代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//js代码</span><br><span class="line">render (createElement) &#123;</span><br><span class="line">     return (</span><br><span class="line">         &lt;button content=&#123;this.generatedText&#125;&gt;&lt;/button&gt;     )</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>目录</p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><p>分割线</p><hr><p>12312</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>html中link标签怎么用（前端link和@import的区别在哪）</title>
      <link href="/2022/12/30/html%E4%B8%ADlink%E6%A0%87%E7%AD%BE%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%88%E5%89%8D%E7%AB%AFlink%E5%92%8C-import%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%EF%BC%89/"/>
      <url>/2022/12/30/html%E4%B8%ADlink%E6%A0%87%E7%AD%BE%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%88%E5%89%8D%E7%AB%AFlink%E5%92%8C-import%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>link 标签是干嘛的？</p><p>link 标签是定义文档与外部资源的关系。link 标签是最常见的用途是链接样式表。通过预处理提升渲染速度 在我们对中大型项目进行性能优化时，往往会对资源做减法（gzip 压缩，缓存等）或除法（按需打包，按需加载），可是如果能想到 link 标签的 rel 属性值来进行预加载，也能加快页面的渲染速度。</p><p>html 中 link 标签怎么用看如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;!-- 通过link标签引入a.css文件样式 --&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;./a.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;测试111&lt;/div&gt;</span><br><span class="line">  &lt;p&gt;测试222&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>@import 的使用方法 a.css 文件代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/_ a.css 文件内容 _/</span><br><span class="line">/_ 通过@import 引入 b.css 样式 _/</span><br><span class="line">@import &#x27;./b.css&#x27;;</span><br><span class="line">div&#123;</span><br><span class="line">background-color: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@import 的使用方法 b.css 文件代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/_ b.css 文件内容 _/</span><br><span class="line">p&#123;</span><br><span class="line">color:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &#x27;./b.css&#x27;; //在 a.css 文件中 把 b.css 样式引入到 a.css 文件</span><br></pre></td></tr></table></figure><p>截图：<br>其中方括号是图片描述，圆括号是图片路径。</p><p>一般来说有三种图片路径，分别是相对路径，绝对路径和网络路径。<br><img src="https://tangjiusheng.com/d/file/p/2022/11-01/ea0020e59fd64ddc68dd1ed164cd7cba.jpg?image_process=resize,p_80" alt="复制的图片"></p><p>A标签跳转<br>More info: <a href="https://www.baidu.com/s?wd=hexo%20%E5%9B%BE%E7%89%87&rsv_spt=1&rsv_iqid=0xf02f7de700005da1&issp=1&f=8&rsv_bp=1&rsv_idx=2&ie=utf-8&rqlang=cn&tn=baiduhome_pg&rsv_enter=0&rsv_dl=tb&oq=hexo%2520%25E5%259B%25BE%25E7%2589%2587&rsv_btype=t&rsv_t=d87cu+n1KQxmURj/6IlgEmZy8HTwTHz7jN3HB8Q4DX+lObrPa1AmEm0y9tHnKZZ2oNkH&rsv_pq=bd1d8cae0000e6fa">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><hr><p>前端 link 和@import 的区别在哪</p><p>1.先有 link，后面再有@import ,link 兼容性比@import 好</p><p>2.加载顺序：浏览器先加载标签 Link，再加载@import</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>wget使用</title>
      <link href="/2022/12/30/wget%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/12/30/wget%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>目录</p><p>一、wget 的下载与安装（错误的安装）</p><p>1.下载</p><p>2.安装</p><p>3.配置环境</p><p>4.验证是否安装成功</p><p>5.可能出现的问题</p><p>二、wget 的卸载（未使用方法一下载过的请忽略）</p><p>三、正确的安装！！！（直接安装请看这里）</p><p>四、wget 的使用</p><p>建议看完下面内容再进行安装！！！！</p><pre><code>    第一章的安装方法是本人尝试后行不通的方法，特此记录以作警示，第三章是本人尝试的可以正确安装的方法，直接安装请移步第三章！！！    对于那些上来就按照第一章操作、不看该块内容的人，我只能说句：活该！！别进来就直接扒饭吃。</code></pre><p>PS：目录也写的很清楚，眼瞎的绕路</p><p>一、wget 的下载与安装（错误的安装） 1.下载<br>wget 下载链接：Wget for Windows (sourceforge.net)</p><p>进入页面后，点击这个链接下载 wget</p><p>进入界面后，点击 download 下载文件</p><p>下载得到.exe 文件</p><p>右键以管理员身份运行，开始安装</p><p>2.安装<br>下面是一路 next</p><p>这个安装目录可以改一下，装到自己想装的位置，并记住这个位置 ，后面需要添加环境</p><p>3.配置环境<br>（1）新建系统变量</p><p>此电脑 → 属性 → 高级系统设置 → 环境变量 → 系统变量 → 新建</p><p>变量名：GUN_HOME</p><p>变量值为你的 wget 的安装路径</p><p>（2）添加环境变量</p><p>系统变量 → 编辑 → 新建 → 输入环境 → 确定</p><p>环境：%GNU_HOME%\bin</p><p>4.验证是否安装成功<br>win+R→cmd→ 输入如下命令</p><p>出现一串命令表示安装成功</p><p>wget –help</p><p>5.可能出现的问题<br>也可能出现以下问题</p><p>尝试了一些方法：</p><p>cd 到这个位置运行命令也不行</p><p>cd C:\Windows\System32</p><p>二、wget 的卸载（未使用方法一下载过的请忽略）<br>相信踩过坑的你肯定安装了无法使用的 wget，既然无法使用，我们就要卸载！！！</p><p>右键运行.exe</p><p>好了卸载了</p><p>记得把刚才配置的环境都删掉！！！</p><p>============================分割线===============================</p><p>三、正确的安装！！！（直接安装请看这里）<br>下面开始解决问题</p><p>去该网址下载二进制文件：GNU Wget 1.21.3 for Windows</p><p>注意：要根据你的电脑选择 32 位还是 64 位，这很重要</p><p>我下载的是这个，仅供参考</p><p>然后你会得到一个.zip 格式的文件夹</p><p>解压，解压到哪里都行</p><p>里面有这些东西</p><p>然后将 wget.exe 复制到 C:\Windows\System32 下，就像这样</p><p>然后 win+R→cmd</p><p>输入 wget，出现如下的界面说明安装成功</p><p>四、wget 的使用</p><h5 id="wget-c-r-npH-k-https-www-zhaoxin-cn"><a href="#wget-c-r-npH-k-https-www-zhaoxin-cn" class="headerlink" title="wget -c -r -npH -k https://www.zhaoxin.cn/"></a>wget -c -r -npH -k <a href="https://www.zhaoxin.cn/">https://www.zhaoxin.cn/</a></h5><p>建议参考这位博主：wget 的使用</p><p>我盘符比较小，所以我需要把文件下载到盘符大的目录</p><p>wget -P 目录地址 下载地址</p><p>注意：目录地址中不能有中文、空格，不然无法解析</p><p>不明白的参考这个博客：指定下载目录</p><p>wget -i filename.txt<br>此命令常用于批量下载的情形，把所有需要下载文件的地址放到 filename.txt 中，然后 wget 就会自动为你下载所有文件了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫相关</title>
      <link href="/2022/12/30/%E7%88%AC%E8%99%AB%E7%9B%B8%E5%85%B3/"/>
      <url>/2022/12/30/%E7%88%AC%E8%99%AB%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>robots.txt写法大全和robots.txt语法的作用<br>1如果允许所有搜索引擎访问网站的所有部分的话 我们可以建立一个空白的文本文档，命名为robot<br>s.txt放在网站的根目录下即可。<br>robots.txt写法如下：<br>User-agent: *<br>Disallow:<br>或者<br>User-agent: *<br>Allow: /<br>2如果我们禁止所有搜索引擎访问网站的所有部分的话<br>robots.txt写法如下：<br>User-agent: *<br>Disallow: /<br>3如果我们需要某一个搜索引擎的抓取的话，比如百度，禁止百度索引我们的网站的话<br>robots.txt写法如下：<br>User-agent: Baiduspider<br>Disallow: /<br>4如果我们禁止Google索引我们的网站的话，其实跟示例3一样，就是User-agent:头文件的蜘蛛名<br>字改成谷歌的Googlebot<br>即可<br>robots.txt写法如下：<br>User-agent: Googlebot<br>Disallow: /<br>5如果我们禁止除Google外的一切搜索引擎索引我们的网站话<br>robots.txt写法如下：<br>User-agent: Googlebot<br>Disallow:<br>User-agent: *<br>Disallow: /<br>6如果我们禁止除百度外的一切搜索引擎索引我们的网站的话<br>robots.txt写法如下：<br>User-agent: Baiduspider<br>Disallow:<br>User-agent: *<br>Disallow: /<br>7如果我们需要禁止蜘蛛访问某个目录，比如禁止admin、css、images等目录被索引的话<br>robots.txt写法如下：<br>User-agent: *<br>Disallow: /css/<br>Disallow: /admin/<br>Disallow: /images/<br>8如果我们允许蜘蛛访问我们网站的某个目录中的某些特定网址的话<br>robots.txt写法如下：<br>User-agent: *<br>Allow: /css/my<br>Allow: /admin/html<br>Allow: /images/index<br>Disallow: /css/<br>Disallow: /admin/<br>Disallow: /images/<br>9我们看某些网站的robots.txt里的Disallow或者Allow里会看很多的符号，比如问号星号什么的，<br>如果使用“<em>”，主要是限制访问某个后缀的域名，禁止访问/html/目录下的所有以”.htm”为后缀的<br>URL(包含子目录)。<br>robots.txt写法如下：<br>User-agent: *<br>Disallow: /html/</em>.htm<br>10如果我们使用“$”的话是仅允许访问某目录下某个后缀的文件<br>robots.txt写法如下：<br>User-agent: *<br>Allow: .asp$<br>Disallow: /<br>11如果我们禁止索引网站中所有的动态页面（这里限制的是有“?”的域名，例如index.asp?id=1<br>robots.txt写法如下：<br>User-agent: *<br>Disallow: /<em>?</em><br>有些时候，我们为了节省服务器资源，需要禁止各类搜索引擎来索引我们网站上的图片，这里的办<br>法除了使用“Disallow: /images/”这样的直接屏蔽文件夹的方式之外，还可以采取直接屏蔽图片<br>后缀名的方式。<br>示例12<br>如果我们禁止Google搜索引擎抓取我们网站上的所有图片(如果你的网站使用其他后缀的图片名称<br>，在这里也可以直接添加)<br>robots.txt写法如下：<br>User-agent: Googlebot<br>Disallow: .jpg$<br>Disallow: .jpeg$<br>Disallow: .gif$<br>Disallow: .png$<br>Disallow: .bmp$<br>13如果我们禁止百度搜索引擎抓取我们网站上的所有图片的话<br>robots.txt写法如下：<br>User-agent: Baidus<br>pider<br>Disallow: .jpg$<br>Disallow: .jpeg$<br>Disallow: .gif$<br>Disallow: .png$<br>Disallow: .bmp$<br>14除了百度之外和Google之外，禁止其他搜索引擎抓取你网站的图片<br>(注意，在这里为了让各位看的更明白，因此使用一个比较笨的办法——对于单个搜索引擎单独定义<br>。)<br>robots.txt写法如下：<br>User-agent: Baiduspider<br>Allow: .jpeg$<br>Allow: .gif$<br>Allow: .png$<br>Allow: .bmp$<br>User-agent: Googlebot<br>Allow: .jpeg$<br>Allow: .gif$<br>Allow: .png$<br>Allow: .bmp$<br>User-agent: *<br>Disallow: .jpg$<br>Disallow: .jpeg$<br>Disallow: .gif$<br>Disallow: .png$<br>Disallow: .bmp$<br>15仅仅允许百度抓取网站上的“JPG”格式文件<br>（其他搜索引擎的办法也和这个一样，只是修改一下搜索引擎的蜘蛛名称即可）<br>robots.txt写法如下：<br>User-agent: Baiduspider<br>Allow: .jpg$<br>Disallow: .jpeg$<br>Disallow: .gif$<br>Disallow: .png$<br>Disallow: .bmp$<br>16仅仅禁止百度抓取网站上的“JPG”格式文件<br>robots.txt写法如下：<br>User-agent: Baiduspider<br>Disallow: .jpg$<br>17如果 ? 表示一个会话 ID，您可排除所有包含该 ID 的网址，确保 Googlebot 不会抓取重复的网<br>页。但是，以 ? 结尾的网址可能是您要包含的网页版本。在此情况下，沃恩可将与 Allow 指令配合<br>使用。<br>robots.txt写法如下：<br>User-agent:*<br>Allow:/<em>?$<br>Disallow:/</em>?<br>Disallow:/ <em>?<br>一行将拦截包含 ? 的网址（具体而言，它将拦截所有以您的域名开头、后接任意字符串，然后是问<br>号 (?)，而后又是任意字符串的网址）。Allow: /</em>?$ 一行将允许包含任何以 ? 结尾的网址（具体而<br>言，它将允许包含所有以您的域名开头、后接任意字符串，然后是问号 (?)，问号之后没有任何字符<br>的网址）。<br>18如果我们想禁止搜索引擎对一些目录或者某些URL访问的话，可以截取部分的名字<br>robots.txt写法如下：<br>User-agent:*<br>Disallow: /plus/feedback.php?</p><h2 id="以下是百度遵循的robots协议"><a href="#以下是百度遵循的robots协议" class="headerlink" title="以下是百度遵循的robots协议"></a>以下是百度遵循的robots协议</h2><p>User-agent: Baiduspider<br>Disallow: /baidu<br>Disallow: /s?<br>Disallow: /ulink?<br>Disallow: /link?<br>Disallow: /home/news/data/<br>Disallow: /bh</p><p>User-agent: Googlebot<br>Disallow: /baidu<br>Disallow: /s?<br>Disallow: /shifen/<br>Disallow: /homepage/<br>Disallow: /cpro<br>Disallow: /ulink?<br>Disallow: /link?<br>Disallow: /home/news/data/<br>Disallow: /bh</p><p>User-agent: MSNBot<br>Disallow: /baidu<br>Disallow: /s?<br>Disallow: /shifen/<br>Disallow: /homepage/<br>Disallow: /cpro<br>Disallow: /ulink?<br>Disallow: /link?<br>Disallow: /home/news/data/<br>Disallow: /bh</p><p>User-agent: Baiduspider-image<br>Disallow: /baidu<br>Disallow: /s?<br>Disallow: /shifen/<br>Disallow: /homepage/<br>Disallow: /cpro<br>Disallow: /ulink?<br>Disallow: /link?<br>Disallow: /home/news/data/<br>Disallow: /bh</p><p>User-agent: YoudaoBot<br>Disallow: /baidu<br>Disallow: /s?<br>Disallow: /shifen/<br>Disallow: /homepage/<br>Disallow: /cpro<br>Disallow: /ulink?<br>Disallow: /link?<br>Disallow: /home/news/data/<br>Disallow: /bh</p><p>User-agent: Sogou web spider<br>Disallow: /baidu<br>Disallow: /s?<br>Disallow: /shifen/<br>Disallow: /homepage/<br>Disallow: /cpro<br>Disallow: /ulink?<br>Disallow: /link?<br>Disallow: /home/news/data/<br>Disallow: /bh</p><p>User-agent: Sogou inst spider<br>Disallow: /baidu<br>Disallow: /s?<br>Disallow: /shifen/<br>Disallow: /homepage/<br>Disallow: /cpro<br>Disallow: /ulink?<br>Disallow: /link?<br>Disallow: /home/news/data/<br>Disallow: /bh</p><p>User-agent: Sogou spider2<br>Disallow: /baidu<br>Disallow: /s?<br>Disallow: /shifen/<br>Disallow: /homepage/<br>Disallow: /cpro<br>Disallow: /ulink?<br>Disallow: /link?<br>Disallow: /home/news/data/<br>Disallow: /bh</p><p>User-agent: Sogou blog<br>Disallow: /baidu<br>Disallow: /s?<br>Disallow: /shifen/<br>Disallow: /homepage/<br>Disallow: /cpro<br>Disallow: /ulink?<br>Disallow: /link?<br>Disallow: /home/news/data/<br>Disallow: /bh</p><p>User-agent: Sogou News Spider<br>Disallow: /baidu<br>Disallow: /s?<br>Disallow: /shifen/<br>Disallow: /homepage/<br>Disallow: /cpro<br>Disallow: /ulink?<br>Disallow: /link?<br>Disallow: /home/news/data/<br>Disallow: /bh</p><p>User-agent: Sogou Orion spider<br>Disallow: /baidu<br>Disallow: /s?<br>Disallow: /shifen/<br>Disallow: /homepage/<br>Disallow: /cpro<br>Disallow: /ulink?<br>Disallow: /link?<br>Disallow: /home/news/data/<br>Disallow: /bh</p><p>User-agent: ChinasoSpider<br>Disallow: /baidu<br>Disallow: /s?<br>Disallow: /shifen/<br>Disallow: /homepage/<br>Disallow: /cpro<br>Disallow: /ulink?<br>Disallow: /link?<br>Disallow: /home/news/data/<br>Disallow: /bh</p><p>User-agent: Sosospider<br>Disallow: /baidu<br>Disallow: /s?<br>Disallow: /shifen/<br>Disallow: /homepage/<br>Disallow: /cpro<br>Disallow: /ulink?<br>Disallow: /link?<br>Disallow: /home/news/data/<br>Disallow: /bh</p><p>User-agent: yisouspider<br>Disallow: /baidu<br>Disallow: /s?<br>Disallow: /shifen/<br>Disallow: /homepage/<br>Disallow: /cpro<br>Disallow: /ulink?<br>Disallow: /link?<br>Disallow: /home/news/data/<br>Disallow: /bh</p><p>User-agent: EasouSpider<br>Disallow: /baidu<br>Disallow: /s?<br>Disallow: /shifen/<br>Disallow: /homepage/<br>Disallow: /cpro<br>Disallow: /ulink?<br>Disallow: /link?<br>Disallow: /home/news/data/<br>Disallow: /bh</p><p>User-agent: *<br>Disallow: /</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git-page</title>
      <link href="/2022/12/23/git-page/"/>
      <url>/2022/12/23/git-page/</url>
      
        <content type="html"><![CDATA[<p>切换主分支 git  pull<br>切换 自己分支 git merge master</p><p>在项目所在位置打开git-bash， 在git bash交互环境输入命令：<br>git config credential.helper store<br>不加参数： –global 只对这个仓库生效，并非全局设置 。<br>后续正常 push，第一次要输入账号密码，以后就不用了。</p><p>使用git pull或者git push每次都需要输入用户名和密码很繁琐，耽误时间，现在教大家一条命令实现保存用户名和密码不用再输入<br>git config –global credential.helper store</p><p>git pull /git push (第一次输入，后续就不用再次数据)</p><p>push你的代码 (git push), 这时会让你输入用户名和密码, 这一步输入的用户名密码会被记住, 下次再push代码时就不用输入用户名密码 ! 这一步会在用户目录下生成文件.git-credential记录用户名密码的信息。</p><p>如何让他再次失效呢</p><p>1<br>git提交时不用输入用户名密码的方法<br>在git push时每次都要输入用户名和密码是一件很痛苦的事，其实解决方法很简单，在文件夹（包含隐藏文件夹.git文件夹的）内右键 git bash here</p><p>在git bash交互环境输入命令</p><p>git config credential.helper store<br>这里没有–global意思是指只对这个仓库生效，建议以后都不要加–global</p><p>让代码配置以仓库为单位存储就好，设置成全局不灵活</p><p>打开.git文件夹的.config文件，回发现多了两行</p><p>[credential]</p><p>helper=store<br>git push 到远程仓库，输入用户名和密码，注意要输入正确的</p><p>再次运行git push 就不用输入用户名和密码了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>interview-page</title>
      <link href="/2022/12/23/interview-page/"/>
      <url>/2022/12/23/interview-page/</url>
      
        <content type="html"><![CDATA[<ol><li>自我介绍</li><li>上家公司与当前位置</li><li>为什么从上家公司离职</li><li>你的优点与缺点是什么</li><li>人员组成</li><li>项目如何分工</li><li>你有什么想问我的吗</li></ol><p>BFC/盒子模型/flex布局/H5新特性/rem适配</p><p>作用域与作用域链<br>闭包<br>函数中的this</p><p>原型与原型链<br>垃圾回收机制<br>JS的事件循环机制<br>promise / async与await<br>箭头函数的特点<br>跨域问题<br>axios的二次封装 =&gt; axios的整体执行流程<br>从输入url到渲染出页面的整个过程<br>函数节流与防抖<br>深拷贝</p><p>区别v-if与v-show<br>为什么v-for与v-if不适合一起使用<br>computed与watcher<br>Vue组件的生命周期<br>组件间通信<br>history与hash路由的区别<br>Vue响应式数据原理<br>$nextTick的原理<br>虚拟DOM与DOM Diff<br>说说vue组件的模板解析<br>说说你对TS的理解<br>说说Vue3的特点</p><p>说说对react的理解<br>说说react的hook<br>说说react组件间通信</p><p>说一下你的项目<br>封装过什么组件<br>遇到过什么问题<br>项目优化<br>权限控制如何实现</p><p>22<br>2000 出生 22岁</p><p>两年经验<br>统–<br>2019.09-2022.06<br>非<br>2018.09-2021.06<br>2019.09 2020.06 2021.06 2022.06<br>21  22 </p><p>爱鱼优品<br>这是一个使用uniapp vant 搭建的小程序app<br>主要有首页、分类页、购物车页、个人中心页<br>‘</p><p>screenHeight是手机屏幕的总高度，包含状态栏、导航栏、页面内容。状态栏是手机最上面显示信号、电量的那一小条。导航栏是显示小程序标题和胶囊按钮的那一条。</p><p>windowHeight是页面内容的高度，默认不包括状态栏和导航栏。但是如果你设置了自定义导航栏（”navigationStyle”:”custom”），它的值就和screenHeight一样了。</p><p>d</p><ol><li></li></ol><p>2021.07 2022.09   武汉CET中电技术有限公司       web前端开发<br>岗位职责：</p><ol><li>   与产品和后端进行密切交流和合作，共同研讨产品和技术的实现方案；</li><li>   与UI设计师、交互设计师合作完成具有良好的兼容性和适用性的产品；</li><li>   遵守代码规范，编写结构清晰、可维护性强、高质量、高效率的代码；</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/12/21/hello-world/"/>
      <url>/2022/12/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>编程干货️为什么说PHP是世界上最好的语言</title>
      <link href="/2022/08/10/02-page/"/>
      <url>/2022/08/10/02-page/</url>
      
        <content type="html"><![CDATA[<p>PHP领域较新，目前发展非常快，很多软硬件技术出现的时间都不太长（如ARM处理器、PHP操作系统、LINUX操作系统），大多数人没有条件接触或进入PHP行业，更谈不上能有机会接受专业人士的指导。因此，踏进这个行业的难度比较大，PHP人才稀缺，身价自然也水涨船高。</p><p>权威部门统计，我国PHP人才缺口每年50万人左右。根据前程无忧网发布的调查报告，PHP软件开发是未来几年热门和受欢迎的职业之一，具有10年工作经验的高级PHP工程师年薪在30万元左右。即使是初级的PHP软件开发人员，平均月薪也达到了4000—7000元，中高级的PHP工程师月薪平均超过10000元。 做软件实际上有高下之分，开发语言从机器语言、汇编到C、C++，再到红透半边天的Java、C＃等，该学哪种呢？为什么有些开发者工资低，而有些开发者千金难求？为什么3年的Java高级程序员薪水仅仅8k-10k，而一个Linux底层C语言程序员两年经验就敢要10k的薪水？</p><p>还是门槛，比如月薪15k的LinuxPHP开发职位，门槛就有 Linux系统、Shell编程、Linux开发环境、C语言、ARM硬件平台、数据结构、Linux内核、驱动程序等，粗略数数就有8道关口，他需要非常熟悉整个的计算机体系，能做出实际的产品，而Java的开发者却仅仅是会使用名叫Java的语言工具，始终高高飘在众多层次之上，开发项目非常快，甚至可以不知道OSI模型，很可能自始至终都是软件蓝领。</p><p>PHP开发本身也有高下之分，至少包含PHP应用程序工程师和底层的驱动内核工程师两种。前者同样是使用现成工具进行简单劳动，比如使用J2ME开发小游戏或者进行一些界面开发，而后者是根据芯片具体情况把操作系统（如Linux）移植到上面，同时编写必要的驱动程序，改写相应的内核代码。很显然后者是一个公司真正的技术核心。而技术核心的工资很可能是其他开发者的数倍。</p><p>PHP开发突出强制和项目，学习不仅仅是学习几项技术，而是构建你的知识体系。比如学习PHP开发，就要从基础Linux，C语言，数据结构开始，到ARM，汇编，Linux内核、驱动等，更重要的是更多的项目练习，设计至少5个项目，多达10000行强制核心代码的编写可以让你真正获得知识。为进入外企或者出国做准备。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github博客搭建记录</title>
      <link href="/2019/08/10/my-first-page/"/>
      <url>/2019/08/10/my-first-page/</url>
      
        <content type="html"><![CDATA[<p>1.git安装<br>前往git官网下载安装git，官网地址：Git - Downloads (git-scm.com)、<br>相关教程：Git下载安装及设置详细教程_sanxd的博客-CSDN博客_git 安装<br>环境变量配置：在PATH下添加Git和Git/bin的路径。</p><p>2.node.js安装<br>前往官网下载node.js，官网地址Download | Node.js (nodejs.org)<br>环境变量配置：在PATH下添加npm的路径。</p><p>3.hexo安装<br>在命令行中输入npm install -g hexo-cli命令进入hexo的安装。<br>环境变量配置：在PATH下添加hexo-cli和.bin的路径。<br>完成所有配置后，在cmd中输入如图所示内容查看路径是否配置正确及版本。</p><p>4.hexo相关命令操作：<br>hexo init <folder>创建一个新的网页项目<br>hexo new page <name>创建一个新的网页文件夹<br>hexo new <name>创建一个新的md文章<br>hexo clean清空本地生成<br>hexo g本地生成<br>hexo s端口生成<br>hexo d自动部署</p><p>5.本地生成网页基本操作<br>例如<br>hexo init C:\Users\Lenovo\Desktop\text<br>在桌面test文件夹生成网页项目。</p><p>cd C:\Users\Lenovo\Desktop\text<br>进入网页项目文件夹<br>hexo new first_blog<br>hexo g &amp;&amp; hexo s<br>部署到端口，然后就可以进入<a href="http://localhost:4000/">http://localhost:4000</a> 查看你的新网页啦。</p><p>6.部署到USTC服务器<br>FileZilla的安装<br>登陆 home.ustc.edu.cn （连接校园网下按下面操作提示即可）<br>服务器上传<br>在服务器下创建public_html文件夹，然后将本地网页中的public文件夹下所有内容传上即可。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
